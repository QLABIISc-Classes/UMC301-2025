## Google Agent2Agent (A2A Protocol)

### Why A2A?

As agents become more specialized, tasks like planning an international trip require coordinating multiple agents (e.g., for flights, hotels, tours). Without a common protocol, this creates significant engineering hurdles for several key reasons:

- Lack of Dynamic Discovery: A client agent cannot dynamically find the best service for a job or discover alternatives if a primary agent fails, as connections are often hardcoded.

- Brittle, Custom Integrations: Each connection requires custom code, leading to a complex architecture that is difficult to scale and maintain.

- Poor Support for Agentic Workflows: Traditional request-response APIs are ill-suited for the long-running, asynchronous, and multi-turn conversations that are common in agent interactions.

### Key Components

![Key Components](assets/a2a-actors.png)

#### Core Actors

The protocol defines three distinct roles in any interaction:

- User: The end-user, who can be a human or another automated service, that initiates the goal or request.
- A2A Client (Client Agent): An application or agent that acts on the user's behalf. It is responsible for initiating communication and sending tasks to other agents.
- A2A Server (Remote Agent): An agent that exposes an A2A-compliant HTTP endpoint. It receives, processes, and responds to tasks sent by clients.

#### Communication Objects

These are the standardized data structures that agents exchange:

- Agent Card: A public JSON file that serves as an agent's profile. It's used for discovery and details the agent's identity, its specific skills, its endpoint URL, and its security/authentication requirements.

- Task: The central, stateful object representing an entire job or conversation. It is identified by a unique ID and has a defined lifecycle (submitted, working, input-required, completed, etc.), which allows for tracking long-running, multi-step processes.

- Message: Represents a single turn of communication within a task. It has a role (either "user" or "agent") to structure the dialogue and contains one or more Part objects.

- Part: The fundamental unit of content within a Message or Artifact. The protocol defines specific types to handle multi-modal data: TextPart for plain text, FilePart for binary data (like images or PDFs), and DataPart for structured JSON (like forms).

- Artifact: Represents a final, immutable output generated by the remote agent as a result of a task. This could be a generated file, a spreadsheet, or structured data, and is distinct from the conversational messages exchanged during processing.

#### Key Interaction Mechanisms

A2A supports three flexible models for communication to suit different needs:

- Request/Response (Polling): The standard model where a client sends a request. For long-running tasks, the server can immediately acknowledge the task, and the client can periodically poll a tasks/get endpoint to check the status until it's complete.

- Streaming (Server-Sent Events - SSE): For real-time updates, a client can subscribe to a task. This keeps a connection open, allowing the server to push status updates or incremental results to the client as they happen, eliminating the need for polling.

- Push Notifications (Webhooks): For very long-running or offline tasks where a persistent connection isn't feasible, a client can provide a webhook URL. The server can then send an HTTP POST request to this URL to notify the client of any important task updates.


### The A2A Communication

A2A interactions follow a structured, four-stage lifecycle built on JSON-RPC 2.0 over HTTP.

- Discovery: The client agent first fetches the remote agent's Agent Card to learn its capabilities and endpoint URL.

- Initiation: The client sends an HTTP POST request to the remote agent's endpoint. The body of this request is a JSON-RPC envelope containing the A2A method (e.g., tasks/send) and the params, which hold the Task object and initial Message.

- Processing & Interaction: The remote agent begins processing the task, using one of the interaction mechanisms described above (Polling, Streaming, or Push Notifications) to communicate its progress. If the task requires more information, it can enter the input-required state to facilitate a multi-turn conversation.

- Completion: Once the task is finished, its state transitions to completed, and the final Artifact is made available to the client.

By standardizing this entire lifecycle, the A2A protocol provides the robust and flexible foundation needed to move from a world of isolated AIs to a truly collaborative and interconnected digital ecosystem.

## Additonal Resources
1. https://google-a2a.github.io/A2A/latest/
2. https://developers.googleblog.com/en/a2a-a-new-era-of-agent-interoperability/
3. https://github.com/google-a2a/A2A
4. https://medium.com/google-cloud/getting-started-with-google-a2a-a-hands-on-tutorial-for-the-agent2agent-protocol-3d3b5e055127
5. https://medium.com/@elisowski/what-every-ai-engineer-should-know-about-a2a-mcp-acp-8335a210a742
